<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <title>My first Three.js app</title>
  <style>
  body { margin: 0; }
  #texture {
    position:absolute;
    top:0;
    left:0;
    margin:0;
    padding:0;
    width:400px;
    height:400px;
    z-index: 2;
    background-color:white;
  }
  #webgl-canvas {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
  }
  </style>
</head>
<body>
<canvas id="texture" width="400" height="400"></canvas>
<script src="lib/three.js"></script>
<script src="lib/OrbitControls.js"></script>
<script>
var texture = document.getElementById('texture');




var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 3;

var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.id = "wegbl-canvas";
document.body.appendChild(renderer.domElement);

var geometry = new THREE.SphereGeometry(1, 32, 32);
geometry.faces.forEach(function(face, faceIndex) {
  var va = geometry.vertices[face.a];
  var vb = geometry.vertices[face.b];
  var vc = geometry.vertices[face.c];
  var uv = geometry.faceVertexUvs[0][faceIndex];
  var abcs = [];
  ['a', 'b', 'c'].forEach(function(vi, i) {
    uv[i].x = geometry.vertices[face[vi]].x / 2 + 0.5;
    uv[i].y = geometry.vertices[face[vi]].y / 2 + 0.5;
  });
});
//var material = new THREE.MeshPhongMaterial();
var material = new THREE.MeshBasicMaterial({map:new THREE.Texture(texture)});
var sphereMesh = new THREE.Mesh(geometry, material);
if (true) {
  sphereMesh.material.transparent = true;
  sphereMesh.material.opacity = 0;
}
scene.add(sphereMesh);

var geometry2 = new THREE.TorusKnotGeometry(1, 0.3, 256, 32);
//var geometry2 = new THREE.TorusGeometry(1, 0.3, 256, 32);
//var geometry2 = new THREE.BoxGeometry(1, 1, 1);
var material2 = new THREE.MeshBasicMaterial({map:new THREE.Texture(texture)});
var targetMesh = new THREE.Mesh(geometry2, material2);
scene.add(targetMesh);

var raycaster = new THREE.Raycaster(new THREE.Vector3());
targetMesh.geometry.faces.forEach(function(face, faceIndex) {
  var origin = sphereMesh.position.clone().add(face.normal.clone().multiplyScalar(2));
  var direction = face.normal.clone().negate();
  raycaster.set(origin, direction);
  var intersects = raycaster.intersectObject(sphereMesh);
  if (0 < intersects.length) {
    var intersect = intersects[0];
    var uv = sphereMesh.geometry.faceVertexUvs[0][intersect.faceIndex];
    for (var i = 0; i < 3; i++) {
      targetMesh.geometry.faceVertexUvs[0][faceIndex][i].copy(uv[i]);
    }
  }
  else {
    console.log("intersects is []");
    //throw "intersects is []";
  }
});

var light = new THREE.DirectionalLight(0xffffff);
light.position.set(1, 1, 1);
scene.add(light);
light = new THREE.DirectionalLight(0xffffff, 0.5);
light.position.set(-1, -1, -1);
scene.add(light);

var ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);

var controls = new THREE.OrbitControls(camera, renderer.domElement);

function render() {
  requestAnimationFrame(render);
  controls.update();
  renderer.render(scene, camera);
}
render();






var gc = texture.getContext('2d');
var image = new Image();
image.onload = function() {
  gc.drawImage(image, 0, 0);
  material.map.needsUpdate = true;
  material2.map.needsUpdate = true;
};
image.src = "texture.png";
</script>
</body>
</html>
